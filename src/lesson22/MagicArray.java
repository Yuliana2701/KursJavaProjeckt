package lesson22;

import java.util.Arrays;

public class MagicArray {
    int[] array;// null
    int cursor; // по умолчанию = 0

// Методы разширяющие функционал массива

    public MagicArray() {
        this.array = new int[10];// [0, 0, 0....]
    }
// Конструктор (опционально)
    public MagicArray(int[] array) {
        // Todo homework
    }

    //1.Метод добавления в массив одного элемента
    void add(int value) {
        // Проверка! Есть ли вообще свободное место в массиве
        // Если нет - то нужно добавить его
        if (cursor == array.length) {
            //разширить внутренний массив перед добавлением нового значения
            expandArray();
        }


        array[cursor] = value;
        cursor++;

    }

    // 2.Динамическое разширение массива
    void expandArray() {
        System.out.println("Разширяем внутренний массив! Курсор: " + cursor);

        /*
        1.Создать массив большего размера(в 2 раза больше) ++
        2.Переписать в новый массив все значения из старого(до курсора) ++
        3.Перебросить ссылку

         */

        //1.
        int[] newArray = new int[array.length * 2];

        //2.
        for (int i = 0; i < cursor; i++) {
            newArray[i] = array[i];


        }
        //3.Перебрассываем ссылку. Переменная array хранит ссылку на новый массив
        array = newArray;

    }

    //4.Добавление в массив нескольких элементов
    void add(int... numbers) {
        // с numbers я могу обращаться также как  и со ссылкой на массив int
        //   System.out.println("Принял несколько int: " + numbers.length);
        // System.out.println(Arrays.toString(numbers));
        //System.out.println(" каждого int есть свой индекс, как в массиве: " + numbers[0]);

        // Перебираю все значения, для каждого вызываю метод add()
        for (int i = 0; i < numbers.length; i++) {
            add(numbers[i]);
        }
    }

    //3.Возвращает строковое представление массива
    //[5, 20, 45]
    public String toString() {

        if (cursor == 0) return "[]";
        String result = "[";
        for (int i = 0; i < cursor; i++) {
            result += array[i] + (i < cursor - 1 ? ", " : "]");
        }
        return result;

    }

    // 5.Текущее количество элементов в массиве
    int size() {
        return cursor;
    }

    //6.Возвращает значение по индексу
    int get(int index) {
        // Проконтролировать входящий индекс!
        if (index >= 0 && index < cursor) {
            return array[index];
        }
        //Fixme указать место в коде с ошибкой / проблемой
        // Проконтролировать входящий индекс!
        //Хорошего решения нету
        return -2_147_483_647;
        // TOdo поправить обработку некорректного индекса
    }

    //7.Удалить элемент по индексу
    int remove(int index) {
        /*
        1.Прверка индекса на валидность
        2. Удалить значение по индексу
        3.Передвинуть курсор(т.к. количество элементов уменьшилось)
        4.Вернуть старое зеачение
       */

        if (index >= 0 && index < cursor) {
            //логика удаления
            int value = array[index];// запомнить старое значение

            //Перебираем элементы начиная с индекса и перезаписываем значения из ячейки справа
            //Fixme cursor -1
            for (int i = index; i < cursor - 1; i++) {// граница перебора индексов
                array[i] = array[i + 1];
            }
            cursor--;

            return value; //вернуть старое значение

        } else {
            // индекс не валидный
            //Todo поправить возвращаемое значение
            return -2_147_483_647;
        }
    }

    //9.Поиск по значению.Возвращать индекс
    //{1, 100, 5, 24, 0, 5} -> indexOf(5) = 2; indexOf(50) = -1;
    int indexOf(int value) {
        //перебираю все значимые элементы
        // проверяю все элементы, если элемент равен искомому-
        // вернуть индекс такого элемента
        // Если перебрал все элементы - не нашел совпадений- вернуть -1

        for (int i = 0; i < cursor; i++) {
            if (array[i] == value) {
                //Значения совпали.Возвращаю индекс
                return i;

            }

        }
        //Сюда мы попадаем, если не одно значение в массиве не совпало
        return -1;
    }

    //10.Индекс последнего вхождения ++
    //{1, 100, 5, 100, 24, 0, 100} - lastIndexOf(100) -> 6
    //Todo homework
    int lastIndexOf(int value) {
        // Идем по массиву с конца
        for (int i = array.length - 1; i >= 0; i--) {
            if (array[i] == value) {
                return i; // Возвращаем индекс, если нашли значение
            }
        }
        return -1; // Если элемент не найден, возвращаем -1
    }

    // 8.Удаление элемента по значению.Возвращал boolean. Если удалил - вернет true. Не нашел, что удалил - false ++
    boolean removeByValue(int value) {
        for (int i = 0; i < cursor; i++) {
            if (array[i] == value) {
                //Значения совпали.Возвращаю индекс
                return true;
            }

        }
        //Сюда мы попадаем, если не одно значение в массиве не совпало

        //Todo homework

        return false; // Элемент не найден


        }

        //{1, 100, 5, 100, 24, 0, 100}
        // int[] findAllValues(int value){
        //  {1, 3, 6}
        // return null;

        //методы расширяющие функционал массива
        void test () {
            System.out.println(Arrays.toString(array));

        }

    }


// [5, 20]
/*
1. Добавлять элемент в массив ( не думая об индексах и размере массива)++
2.Динамическое изменение размера внутреннего массива++
3.Возвратить строковое представление массива( все элементы массива в одной строке)(какие элементы есть)++
4.Добавить в массив несколько значений ++
5.Текущее количество элементов в массиве++
6.Возвращает значение по индексу++
7.Удалить элемент по индексу (есть индекс- удалить элемент из массива)++
Я хочу, чтоб возвращалось старое значение++
8.Удаление лемента по значению.Возвращал boolean. Если удалил - вернет true. Не нашел, что удалил - false++
9.Поиск по значению.Возвращать индекс первого вхождения++
10. Возврат последнего индекса вхождения++
11. Конструктор, принимающий обычный массив. Создать магический массив с элементами из этого массива
 */